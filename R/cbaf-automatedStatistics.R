#' @title Performing the requested statistics for various studies / subgroups of a study.
#'
#' @description This function calculates frequency percentage, frequency ratio, mean value and median value of samples greather than
#' specific cutoff in the selected study / subgroups of the study. Furthermore, it can looks for the five genes that contain the highest values
#' in each study / study subgroup. It uses the data generated by obtainOneStudy()/obtainMultipleStudies() function.
#'
#' @details
#' \tabular{lllll}{
#' Package: \tab cBioAutomatedTools \cr
#' Type: \tab Package \cr
#' Version: \tab 0.99.0 \cr
#' Date: \tab 2017-06-22 \cr
#' License: \tab Artistic-2.0 \cr
#' }
#'
#' @import cgdsr Biobase
#'
#' @usage automatedStatistics(obtainedDataType = "multiple studies", submissionName,
#' calculate = c("frequencyPercentage", "frequencyRatio", "meanValue", "medianValue"), cutoff=NULL, round=TRUE, topGenes = TRUE)
#'
#' @param submissionName a character string containing name of interest. It is used for naming the process.
#'
#' @param obtainedDataType a character string that specifies the type of input data to function. Two options are availabe:
#' 'single study' and 'multiple studies'. The function uses 'obtainedDataType' and 'submissionName' to construct
#' the name of input data. Default value is 'multiple studies'.
#'
#' @param calculate a character vector that containes the statistical precedures users prefer the function to compute.
#' Default input is \code{c("frequencyPercentage", "frequencyRatio", "Mean.Value", "medianValue")}. This will tell the function to
#' compute the following:
#' 'frequencyPercentage', which is the number of samples having the value greather than specific cutoff divided by the total sample
#' size for every study / study subgroup;
#' 'frequency ratio', which shows the number of selected samples divided by the total number of samples that give the frequency
#' percentage for every study / study subgroup -to know selecected and total sample sizes only;
#' 'Mean Value', that contains mean value of selected samples for each study;
#' 'Median Value', which shows the median value of selected samples for each study.
#'
#' @param cutoff a number used to limit samples to those that are greather than specific number (cutoff). The default value for
#' methylation data is 0.6 while gene expression studies use default value of 2. For methylation studies, it is
#' \code{observed/expected ratio}, for the rest, it is 'z-score'. TO change the cutoff to any desired number, change the
#' option to \code{cutoff = desiredNumber} in which desiredNumber is the number of interest.
#'
#' @param round a logical value that, if set to be TRUE, will force the function to round all the calculated values
#' to two decimal places. The default value is TRUE.
#'
#' @param topGenes a logical value that, if set as TRUE, causes the function to create three data.frame that contain the five
#' top genes for each cancer. To get all the three data.frames, "Frequency.Percentage", "Mean.Value" and "Median" must have been
#' included for \code{calculate}.
#'
#' @return a list that contains some or all of the following statistical measurements for every gene group, based on what user has chosen:
#' \code{Frequency.Percentage}, \code{Top.Genes.of.Frequency.Percentage}, \code{Frequency.Ratio}, \code{Mean.Value}, \code{Top.Genes.of.Mean.Value},
#' \code{Median}, \code{Top.Genes.of.Median}.
#'
#' @examples
#' # The function must run after one of the obtain studies function, as it process their result.
#' automatedStatistics(obtainedDataType = "single study", "test")
#'
#' @author Arman Shahrisa, \email{shahrisa.arman@hotmail.com} [maintainer, copyright holder]
#' @author Maryam Tahmasebi Birgani, \email{tahmasebi-ma@ajums.ac.ir}
#'



#########################################################################
#########################################################################
########### Automatically calculate statistical measurements ############
#########################################################################
#########################################################################

automatedStatistics<- function(submissionName, obtainedDataType = "multiple studies", calculate = c("frequencyPercentage", "frequencyRatio", "meanValue", "medianValue"),

                              cutoff = NULL, round=TRUE, topGenes = TRUE){

  ##########################################################################
  ########## Prerequisites

  # Obtain the unprocessed data list

  if(obtainedDataType == "multiple studies"){

    databaseSymbol <- "Ob.Mu."

    haultType <- "Pa.Ob.Mu."

  } else if(obtainedDataType == "single study"){

    databaseSymbol <- "Ob.Si."

    haultType <- "Pa.Ob.Si."

  } else{

    stop("'obtainedDataType' must be entered as either 'multiple studies' or 'single study'.")

  }



  # Check submissionName

  if(!is.character(submissionName)){

    stop("'submissionName' must be entered as a character string for naming the process")

  }





  # Check calculate

  if(is.character(calculate)){

    if(!any(calculate %in% c("frequencyPercentage", "frequencyRatio", "meanValue", "medianValue"))){

      stop("'calculate' must contain at least one of the following: 'frequencyPercentage', 'frequencyRatio', 'meanValue' and 'medianValue'.")

    }

  }



  ##########################################################################
  ########## Decide whether functions should stops now!

  # Store the new parameteres

  newParameters <-list()

  newParameters$submissionName <- submissionName

  newParameters$obtainedDataType <- obtainedDataType

  newParameters$calculate <- calculate

  newParameters$cutoff <- cutoff

  newParameters$round <- round

  newParameters$topGenes <- topGenes

  newParameters$HaultOrder <- FALSE





  # Check wheather the requested data exists

  if(!exists(paste(haultType, submissionName, sep = ""))){

    Stop("Please run one of the obtainSingleStudy() or obtainMultipleStudies() functions first")

  } else{


    oldParam <- get(paste(haultType, submissionName, sep = ""))

    desiredTechnique <- oldParam$desiredTechnique

    newParameters$desiredTechnique <- desiredTechnique
  }



  # setting the value for cutoff

  if(desiredTechnique == "methylation"){

    cutoff.phrase <- "obs/exp cutoff"

    if(is.null(cutoff)){

      cutoff <- 0.6

    }

  } else{

    cutoff.phrase <- "z-score cutoff"

    if(is.null(cutoff)){

      cutoff <- 2

    }

  }



  # Check wheather the requested data exists

  if(exists(paste("Pa.PrData.", submissionName, sep = ""))){

    if(oldParam$HaultOrder == TRUE){

      if(identical(get(paste("Pa.PrData.", submissionName, sep = ""))[-7], newParameters[-7])){

        continue <- FALSE

        newParameters$HaultOrder <- TRUE

        assign(paste("Pa.PrData.", submissionName, sep = ""), newParameters, envir = globalenv())

        print("--- Function 'automatedStatistics()' was skipped: the requested data already exist ---")

      } else{

        continue <- TRUE

      }

    } else{

      continue <- TRUE

    }

  } else{

    continue <- TRUE

  }





  if(continue == TRUE){

    # Getting the source data

    sourceDataList <- get(paste(databaseSymbol, submissionName, sep = ""))

    if(!is.list(sourceDataList)){

      stop(paste("Input database must be a list.", sep = ""))

    }



    ##########################################################################
    ########## Set the function ready to work

    # creating output fortmat

    processedList <- list()

    options(stringsAsFactors = FALSE)



    # Create a progressbar

    automatedStatisticsProgressBar <- txtProgressBar(min = 0, max = length(sourceDataList[[1]])*length(sourceDataList), style = 3)

    ExtA <- 0



    ##########################################################################
    ########## Core segment

    # Report

    print(paste("***", "Performing the requested statistical analyses for", submissionName, "***", sep = " "))



    # calculating the first 'for' loop for different gene groups

    for(gg in 1:length(sourceDataList)){

      geneNumber <- ncol(sourceDataList[[gg]][[1]])

      temList <- list()



      for(cs in 1:length(sourceDataList[[1]])){

        # start working on one study

        source.data.subset <- sourceDataList[[gg]][[cs]]

        source.data.subset.name <- names(sourceDataList[[gg]])[cs]

        genes.involved <- colnames(sourceDataList[[gg]][[cs]])





        # Creating and filling the empty matrix with frequency.percentage data

        if("frequencyPercentage" %in% calculate){

          # creating empty matrix

          frequency.percentage.for.a.subset <- matrix(, nrow = 1, ncol = geneNumber)

          dimnames(frequency.percentage.for.a.subset) <- list(source.data.subset.name, genes.involved)



          # calculate frequency percentage

          for(fp in 1:geneNumber){

            # Check all members are under cutoff

            if(!is.na(mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp])])) &

               is.nan(mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp]) >= cutoff], na.rm=TRUE))){

              frequency.percentage.for.a.subset[1, fp] <- 0

              # Check all members are NaN

            } else if (length((source.data.subset[,fp])[!is.nan(source.data.subset[,fp])]) == 0 & all(!is.finite(source.data.subset[,fp])) &

                       is.nan(mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp]) >= cutoff], na.rm=TRUE))){

              frequency.percentage.for.a.subset[1, fp] <- NaN

              # Check all members are NA

            } else if (length((source.data.subset[,fp])[!is.nan(source.data.subset[,fp])]) > 0 & all(!is.finite(source.data.subset[,fp])) &

                       is.nan(mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp]) >= cutoff], na.rm=TRUE))){

              frequency.percentage.for.a.subset[1, fp] <- NA

              # Mean is bigger than 0

            } else if (mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp]) >= cutoff], na.rm=TRUE) > 0 &

                       !is.nan(mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp]) >= cutoff], na.rm=TRUE))){

              frequency.percentage.for.a.subset[1, fp] <- 100*mean(as.vector(abs(source.data.subset[,fp]) >= cutoff), na.rm=TRUE)

              # Mean is smaller than 0

            } else if (mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp]) >= cutoff], na.rm=TRUE) < 0 &

                       !is.nan(mean(as.vector(source.data.subset[,fp])[abs(source.data.subset[,fp]) >= cutoff], na.rm=TRUE))){

              frequency.percentage.for.a.subset[1, fp] <- -100*(mean(as.vector(abs(source.data.subset[,fp]) >= cutoff), na.rm=TRUE))

            }

          }



          # Merging calculations

          if(cs==1){

            if(round==TRUE){

              temList$Frequency.Percentage <- round(frequency.percentage.for.a.subset, digits = 2)

            }else{

              temList$Frequency.Percentage <- frequency.percentage.for.a.subset

            }

          } else if(cs!=1){

            if(round==TRUE){

              temList$Frequency.Percentage <- rbind(temList$Frequency.Percentage, round(frequency.percentage.for.a.subset, digits = 2))

            }else{

              temList$Frequency.Percentage <- rbind(temList$Frequency.Percentage, frequency.percentage.for.a.subset)

            }

          }


          if(topGenes == TRUE){

            # Check if manual naming is requested

            pre.topGenes <- frequency.percentage.for.a.subset

            # Removing NaN and NA

            pre.topGenes[is.nan(pre.topGenes) | is.na(pre.topGenes)] <- 0



            # Finding the top 5 values

            topGenes.values <- head(unique(sort(pre.topGenes, decreasing = TRUE)), n = 5)

            for(topV in 1:length(topGenes.values)){

              topGene.name <- colnames(pre.topGenes)[pre.topGenes %in% topGenes.values[topV]]

              # check whether ttwo or more genes have the same rank

              if(length(topGene.name) > 1){

                topGene.name <- paste(topGene.name, collapse = ", ")

              }

              # rounding

              if(round==TRUE){

                complete.top <- data.frame(topGene = topGene.name, topValue = round(topGenes.values[topV], digits = 2))

              } else{

                complete.top <- data.frame(topGene = topGene.name, topValue = topGenes.values[topV])

              }

              # correcting column names

              colnames(complete.top) <- c(paste(topV, "th ", "Gene", sep=""), paste(topV, "th ", "Value", sep=""))

              # complete dataframe

              if(topV == 1){

                post.topGenes <- complete.top

              } else if(topV > 1){

                post.topGenes <- cbind(post.topGenes, complete.top)

              }

            }

            # correcting rowname

            rownames(post.topGenes) <- source.data.subset.name


            # fixing the problem caused by more thank one gene with same rank

            if(length(topGenes.values) < 5){

              # Repeat unit

              fix.dataframe <- data.frame(topGene = "-", topValue = "-")

              # number of new units

              newUnits <- 5 - length(topGenes.values)

              # finding current number of units

              oldUnits <- length(topGenes.values)

              for(empty in 1:newUnits){

                colnames(fix.dataframe) <- c(paste(oldUnits + empty, "th ", "Gene", sep=""), paste(oldUnits + empty, "th ", "Value", sep=""))

                post.topGenes <- cbind(post.topGenes, fix.dataframe)

              }

            }

            # assigning the value to the second level list

            if(cs == 1){

              temList$Top.Genes.of.Frequency.Percentage <- post.topGenes

            } else if(cs!=1){

              temList$Top.Genes.of.Frequency.Percentage <- rbind(temList$Top.Genes.of.Frequency.Percentage, post.topGenes)

            }

          }

        }










        # Creating and filling the empty matrix with frequency.ratio data

        if("frequencyRatio" %in% calculate){

          # creating empty matrix

          frequency.ratio.for.a.subset <- matrix(, nrow = 1, ncol = geneNumber)

          dimnames(frequency.ratio.for.a.subset) <- list(source.data.subset.name, genes.involved)



          # calculate frequency ratio

          for(fr in 1:geneNumber){

            # Check all members are under cutoff

            if(!is.na(mean(as.vector(source.data.subset[,fr])[abs(source.data.subset[,fr])])) &

               is.nan(mean(as.vector(source.data.subset[,fr])[abs(source.data.subset[,fr]) >= cutoff], na.rm=TRUE))){

              frequency.ratio.for.a.subset[1, fr] <- paste(as.character(0), " out of ", as.character(length(as.vector(source.data.subset[,fr]))), sep="")

              # Check all members are NaN

            } else if (length((source.data.subset[,fr])[!is.nan(source.data.subset[,fr])]) == 0 & all(!is.finite(source.data.subset[,fr])) &

                       is.nan(mean(as.vector(source.data.subset[,fr])[abs(source.data.subset[,fr]) >= cutoff], na.rm=TRUE))){

              frequency.ratio.for.a.subset[1, fr] <- NaN

              # Check all members are NA

            } else if (length((source.data.subset[,fr])[!is.nan(source.data.subset[,fr])]) > 0 & all(!is.finite(source.data.subset[,fr])) &

                       is.nan(mean(as.vector(source.data.subset[,fr])[abs(source.data.subset[,fr]) >= cutoff], na.rm=TRUE))){

              frequency.ratio.for.a.subset[1, fr] <- NA

              # Mean is number

            } else if (!is.nan(mean(as.vector(source.data.subset[,fr])[abs(source.data.subset[,fr]) >= cutoff], na.rm=TRUE))){

              frequency.ratio.for.a.subset[1, fr] <- paste(as.character(length(na.omit(as.vector(source.data.subset[,fr])[abs(source.data.subset[,fr]) >= cutoff]))),

                                                           " out of ", as.character(length(as.vector(source.data.subset[,fr]))), sep="")

            }

          }



          # Merging calculations

          if(cs==1){

            temList$Frequency.Ratio <- frequency.ratio.for.a.subset


          } else if(cs!=1){

            temList$Frequency.Ratio <- rbind(temList$Frequency.Ratio, frequency.ratio.for.a.subset)

          }

        }










        # Creating and filling the empty matrix with mean.value data

        if("meanValue" %in% calculate){

          # creating empty matrix

          mean.value.for.a.subset <- matrix(, nrow = 1, ncol = geneNumber)

          dimnames(mean.value.for.a.subset) <- list(source.data.subset.name, genes.involved)



          # calculate frequency percentage

          for(mv in 1:geneNumber){

            # Check all members are under cutoff

            if(!is.na(mean(as.vector(source.data.subset[,mv])[abs(source.data.subset[,mv])])) &

               is.nan(mean(as.vector(source.data.subset[,mv])[abs(source.data.subset[,mv]) >= cutoff], na.rm=TRUE))){

              mean.value.for.a.subset[1, mv] <- 0

              # Check all members are NaN

            } else if (length((source.data.subset[,mv])[!is.nan(source.data.subset[,mv])]) == 0 & all(!is.finite(source.data.subset[,mv])) &

                       is.nan(mean(as.vector(source.data.subset[,mv])[abs(source.data.subset[,mv]) >= cutoff], na.rm=TRUE))){

              mean.value.for.a.subset[1, mv] <- NaN

              # Check all members are NA

            } else if (length((source.data.subset[,mv])[!is.nan(source.data.subset[,mv])]) > 0 & all(!is.finite(source.data.subset[,mv])) &

                       is.nan(mean(as.vector(source.data.subset[,mv])[abs(source.data.subset[,mv]) >= cutoff], na.rm=TRUE))){

              mean.value.for.a.subset[1, mv] <- NA

              # Mean is number

            } else if (!is.nan(mean(as.vector(source.data.subset[,mv])[abs(source.data.subset[,mv]) >= cutoff], na.rm=TRUE))){

              mean.value.for.a.subset[1, mv] <- mean(as.vector(source.data.subset[,mv])[abs(source.data.subset[,mv]) >= cutoff], na.rm=TRUE)

            }

          }



          # Merging calculations

          if(cs==1){

            if(round==TRUE){

              temList$Mean.Value <- round(mean.value.for.a.subset, digits = 2)

            }else{

              temList$Mean.Value <- mean.value.for.a.subset

            }

          } else if(cs!=1){

            if(round==TRUE){

              temList$Mean.Value <- rbind(temList$Mean.Value, round(mean.value.for.a.subset, digits = 2))

            }else{

              temList$Mean.Value <- rbind(temList$Mean.Value, mean.value.for.a.subset)

            }

          }


          if(topGenes == TRUE){

            # Check if manual naming is requested

            pre.topGenes <- mean.value.for.a.subset

            # Removing NaN and NA

            pre.topGenes[is.nan(pre.topGenes) | is.na(pre.topGenes)] <- 0



            # Finding the top 5 values

            topGenes.values <- head(unique(sort(pre.topGenes, decreasing = TRUE)), n = 5)

            for(topV in 1:length(topGenes.values)){

              topGene.name <- colnames(pre.topGenes)[pre.topGenes %in% topGenes.values[topV]]

              # check whether ttwo or more genes have the same rank

              if(length(topGene.name) > 1){

                topGene.name <- paste(topGene.name, collapse = ", ")

              }

              # rounding

              if(round==TRUE){

                complete.top <- data.frame(topGene = topGene.name, topValue = round(topGenes.values[topV], digits = 2))

              } else{

                complete.top <- data.frame(topGene = topGene.name, topValue = topGenes.values[topV])

              }

              # correcting column names

              colnames(complete.top) <- c(paste(topV, "th ", "Gene", sep=""), paste(topV, "th ", "Value", sep=""))

              # complete dataframe

              if(topV == 1){

                post.topGenes <- complete.top

              } else if(topV > 1){

                post.topGenes <- cbind(post.topGenes, complete.top)

              }

            }

            # correcting rowname

            rownames(post.topGenes) <- source.data.subset.name


            # fixing the problem caused by more thank one gene with same rank

            if(length(topGenes.values) < 5){

              # Repeat unit

              fix.dataframe <- data.frame(topGene = "-", topValue = "-")

              # number of new units

              newUnits <- 5 - length(topGenes.values)

              # finding current number of units

              oldUnits <- length(topGenes.values)

              for(empty in 1:newUnits){

                colnames(fix.dataframe) <- c(paste(oldUnits + empty, "th ", "Gene", sep=""), paste(oldUnits + empty, "th ", "Value", sep=""))

                post.topGenes <- cbind(post.topGenes, fix.dataframe)

              }

            }

            # assigning the value to the second level list

            if(cs == 1){

              temList$Top.Genes.of.Mean.Value <- post.topGenes

            } else if(cs!=1){

              temList$Top.Genes.of.Mean.Value <- rbind(temList$Top.Genes.of.Mean.Value, post.topGenes)

            }

          }

        }










        # Creating and filling the empty matrix with median.value data

        if("medianValue" %in% calculate){

          # creating empty matrix

          median.value.for.a.subset <- matrix(, nrow = 1, ncol = geneNumber)

          dimnames(median.value.for.a.subset) <- list(source.data.subset.name, genes.involved)



          # calculate frequency percentage

          for(mdv in 1:geneNumber){

            # Check all members are under cutoff

            if(!is.na(mean(as.vector(source.data.subset[,mdv])[abs(source.data.subset[,mdv])])) &

               is.nan(mean(as.vector(source.data.subset[,mdv])[abs(source.data.subset[,mdv]) >= cutoff], na.rm=TRUE))){

              median.value.for.a.subset[1, mdv] <- 0

              # Check all members are NaN

            } else if (length((source.data.subset[,mdv])[!is.nan(source.data.subset[,mdv])]) == 0 & all(!is.finite(source.data.subset[,mdv])) &

                       is.nan(mean(as.vector(source.data.subset[,mdv])[abs(source.data.subset[,mdv]) >= cutoff], na.rm=TRUE))){

              median.value.for.a.subset[1, mdv] <- NaN

              # Check all members are NA

            } else if (length((source.data.subset[,mdv])[!is.nan(source.data.subset[,mdv])]) > 0 & all(!is.finite(source.data.subset[,mdv])) &

                       is.nan(mean(as.vector(source.data.subset[,mdv])[abs(source.data.subset[,mdv]) >= cutoff], na.rm=TRUE))){

              median.value.for.a.subset[1, mdv] <- NA

              # Mean is number

            } else if (!is.nan(mean(as.vector(source.data.subset[,mdv])[abs(source.data.subset[,mdv]) >= cutoff], na.rm=TRUE))){

              median.value.for.a.subset[1, mdv] <- median(as.vector(source.data.subset[,mdv])[abs(source.data.subset[,mdv]) >= cutoff], na.rm=TRUE)

            }

          }



          # Merging calculations

          if(cs==1){

            if(round==TRUE){

              temList$Median.Value <- round(median.value.for.a.subset, digits = 2)

            }else{

              temList$Median.Value <- median.value.for.a.subset

            }

          } else if(cs!=1){

            if(round==TRUE){

              temList$Median.Value <- rbind(temList$Median.Value, round(median.value.for.a.subset, digits = 2))

            }else{

              temList$Median.Value <- rbind(temList$Median.Value, median.value.for.a.subset)

            }

          }


          if(topGenes == TRUE){

            # Check if manual naming is requested

            pre.topGenes <- median.value.for.a.subset

            # Removing NaN and NA

            pre.topGenes[is.nan(pre.topGenes) | is.na(pre.topGenes)] <- 0



            # Finding the top 5 values

            topGenes.values <- head(unique(sort(pre.topGenes, decreasing = TRUE)), n = 5)

            for(topV in 1:length(topGenes.values)){

              topGene.name <- colnames(pre.topGenes)[pre.topGenes %in% topGenes.values[topV]]

              # check whether ttwo or more genes have the same rank

              if(length(topGene.name) > 1){

                topGene.name <- paste(topGene.name, collapse = ", ")

              }

              # rounding

              if(round==TRUE){

                complete.top <- data.frame(topGene = topGene.name, topValue = round(topGenes.values[topV], digits = 2))

              } else{

                complete.top <- data.frame(topGene = topGene.name, topValue = topGenes.values[topV])

              }

              # correcting column names

              colnames(complete.top) <- c(paste(topV, "th ", "Gene", sep=""), paste(topV, "th ", "Value", sep=""))

              # complete dataframe

              if(topV == 1){

                post.topGenes <- complete.top

              } else if(topV > 1){

                post.topGenes <- cbind(post.topGenes, complete.top)

              }

            }

            # correcting rowname

            rownames(post.topGenes) <- source.data.subset.name


            # fixing the problem caused by more thank one gene with same rank

            if(length(topGenes.values) < 5){

              # Repeat unit

              fix.dataframe <- data.frame(topGene = "-", topValue = "-")

              # number of new units

              newUnits <- 5 - length(topGenes.values)

              # finding current number of units

              oldUnits <- length(topGenes.values)

              for(empty in 1:newUnits){

                colnames(fix.dataframe) <- c(paste(oldUnits + empty, "th ", "Gene", sep=""), paste(oldUnits + empty, "th ", "Value", sep=""))

                post.topGenes <- cbind(post.topGenes, fix.dataframe)

              }

            }

            # assigning the value to the second level list

            if(cs == 1){

              temList$Top.Genes.of.Median.Value <- post.topGenes

            } else if(cs!=1){

              temList$Top.Genes.of.Median.Value <- rbind(temList$Top.Genes.of.Median.Value, post.topGenes)

            }

          }

        }

        # Update progressbar

        ExtA <- ExtA + 1

        setTxtProgressBar(automatedStatisticsProgressBar, ExtA)

      }

      # assign the statistics list fot a subgroup of processedList

      processedList[[gg]] <- temList

      names(processedList)[gg] <- names(sourceDataList)[gg]

    }

    # close progressbar

    close(automatedStatisticsProgressBar)

    # Store the parameters for this run

    assign(paste("Pa.PrData.", submissionName, sep = ""), newParameters, envir = globalenv())

    # Export the obtained data as list

    assign(paste("PrData.", submissionName, sep = ""), processedList, envir = globalenv())

  }

}
